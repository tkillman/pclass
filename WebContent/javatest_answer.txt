1) 4번 오크 였다.
2) 2번 썬사에서 개발된 언어
3) oop , 객체지향언어 
4) 1 ????
5) 2 ??????
6) 1
7) 1
8) 1
9) 2 ??
10) 1
11) 구별한다
12) 반드시 지킬 필요는 없지만 여러 프레임워크를 사용하면서 오류가 나지 않으려면 지켜주는게 좋다.
13) 

반드시 지킬  것
ㄱ.첫 글자는 문자,_,$ 가능, 숫자 불가능 , 공백 불가능

관례
ㄱ.첫 글자는 대문자 ㄴ. 카멜 표기법

14)
byte
short
int
long
float
double

boolean
char

15) 10진수 : 189 , 8진수 : 275 , 16진수 : BD

16) char는 4byte 이므로  16bit, 부호가 없다면  2의 16승 

17) float f = (float) d

18) final

19) i ==11 , n ==0

20) 1?????????????? 

21) 에러 발생, int a 의 값이 정의되지 않음.

22) 97 , add(int arr[]) 메소드 : 들어온 int 배열 중 가장 큰 값을 리턴해주는 메소드
'a' 는 char형으로 비교 시 아스키값 97로 비교된다 . {0, 48, 65, 97} 비교 

23)
class test2 {

	public static void main(String[] args) {		
		for(int i=0;i<5;i++){
			for(int j=0;j<5;j++){
				if(j<=i){
					System.out.print("*");
				}else{
					System.out.print("");
				}	
			}//j
			System.out.println("");
		} //i
	}
}

24) final 클래스는 상속이 되지 않는다.

25) 클래스 이름과 메소드 이름이 동일하긴 하지만 대소문자가 틀려서 생성자가 되지 않는다.
ㄱ.둘의 이름의 대소문자를 맞춰서 생성자를 만들어주던가 , ㄴ. 메소드로 쓰려는 것이면 반환형을 명시해준다.

26) s에 'constructor'을 넣고 싶어하는 것 같은데 
그러면 메소드인  void Test()를 반환형 void를 없애고 생성자로 만든다.

27) 메소드마저 private으로 선언하면 다른곳에서 접근할 수가 없다.

28) 인스턴스 변수를 스태틱 메소드에서 부를 순 없다.

29) 10,20

기본형 타입의 변수는  '=' 연산자가 직접 변수에 대입되지만
참조형 타입의 변수는 '=' 연산자가 참조할 뿐 직접적인 값이 변화되는 것은 아니다. 

30) 자신의 생성자 this() , 조상의 생성자 super()
주의점 : ???? 항상 super()를 먼저 부른다???????


31) Test.a = Test.a + a;

 
32) 5 
	sub

상속 받았을 때 변수의 경우 super부터 찾고
메소드가 오버라이딩 됐을 때는 서브 클래스의 메소드가 호출된다.

33) 메인메소드를 가진 클래스를 상속받았으므로 실행 불가

34) Equal 11
a++이 실행되는 순간은 10이므로 if문 안이 실행되고
다음 a 값은 11이 된다.

35) 2, 4byte

36) c , 없으면 기본 생성자를 추가해준다.

37) D

38) c?? 넓게??

39) A

40) A???????

41) A

42) c

43) B,C 

44) c , object

45) 0AB

기본형 타입 65가 Character 클래스에 의해 형변화가 일어남

'A' + 1 이면 연산자에 의해 65+1이 되고 66 -> 마찬가지로 autoboxing에 의해 형변화

46) 4

47) this

48) 클래스는 단순 코드 , 객체는 실제 메모리에 올라가는 형태

49) 오버로딩 : 같은 클래스 내에서 이름이 같은 메소드
	오버라이딩 : 상속받은 클래스의 조상 클래스와 자식클래스의 이름이 같은 메소드

50) 1. static 한 변수에 자신의 객체를 담는다.
    2. 생성자는 private으로 선언해 new 연산자를 통한 객체 생성이 불가능하게 만든다.
    3. public static 객체  메소드이름(){} 를 정의해서 누구나 접근가능하도록 하고
       	메소드를 통해 static 변수를 반환하도록 해준다.

51)

52)






